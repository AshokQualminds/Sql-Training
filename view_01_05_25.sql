--CREATE DATABASE VIEWS
USE 
VIEWS
GO
: 
VIEW IS DB OBJECT IS CALLED SUBSET OF A TABLE. VIEW IS 
ALSO CALLED AS VIRTUAL TABLE BECAUSE IT DOESN'T STORE 
DATA AND IT DOESN'T OCCUPY ANY MEMORY. 

VIWE IS CREATING BY USING "SELECT QUERY" FOR 
GETTING THE REQ.INFORMATION FROM TABLE (BASE TABLE). 

TYPES OF VIEWS: 
A USER CAN CREATE THE FOLLOWING TWO TYPES OF VIEWS 
ON BASE TABLES THOSE ARE, 
1. SIMPLE VIEWS 
2. COMPLEX VIEWS 

1. SIMPLE VIEWS: 
WHEN WE CREATE A VIEW TO ACCESS REQUIRED DATA 
FROM A SINGLE BASE TABLE IS CALLED AS SIMPLE VIEWS. 
THROUGH A SIMPLE VIEW WE CAN PERFORM ALL DML 
(INSERT, UPDATE, DELETE) OPERATIONS ON BASE TABLE. 

SYNTAX: 
CREATE VIEW <VIEW NAME> AS SELECT * FROM <TN> [ WHERE 
<CONDITION>]; 

	CREATE TABLE DEPT
	(ID INT,DEPT VARCHAR(50),LOC VARCHAR(20));
	CREATE VIEW SV1 AS SELECT *FROM DEPT
	SELECT * FROM SV1
	INSERT INTO SV1 VALUES(50,'DBA','HYD')
	UPDATE SV1 
	SET LOC ='INDIA'
	WHERE ID=50
	DELETE FROM SV1 WHERE ID=50


EX1: 
SQL> CREATE VIEW SV1 AS SELECT * FROM DEPT; 
SQL> SELECT * FROM SV1; 
DML OPERATIONS THROUGH A SIMPLE VIEW: 
QL> INSERT INTO SV1 VALUES (50,'DBA','HYD'); 
SQL> UPDATE SV1 SET LOC='INDIA' WHERE DEPTNO=50; 
SQL> DELETE FROM SV1 WHERE DEPTNO=50; 
NOTE: WHENEVER WE PERFORM DML OPERATIONS ON VIEW 
INTERNALLY THE VIEW WILL PERFORM THOSE OPERATIONS ON 
BASE TABLE.
HERE VIEW WILL ACT AS AN INTERFACE BETWEEN 
USER AND BASE TABLE. 
USER <----------> <VIEW> <-----------> BASE TABLE  
	
	CREATE TABLE EMP (EMPNO INT,ENMAE VARCHAR(20),JOB VARCHAR(20),SAL MONEY);
	INSERT INTO EMP VALUES(1,'A','HR',90000)
	DECLARE @OLDNAME NVARCHAR(55) = [EMP.ENAME]
	EXEC SP_RENAME '[EMP].[EMP.ENAME]','ENAME','COLUMN';
	alter table emp alter column empno int not null
	ALTER TABLE EMP Add PRIMARY KEY(empno)
		
		DECLARE @OLDNAME NVARCHAR(55) = [EMP.ENAME]

 
	SELECT *FROM EMP 
	DELETE  FROM EMP WHERE EMPNO=1

	CREATE VIEW SV2 AS SELECT EMPNO,ENAME,JOB,SAL FROM EMP;


EX2: 
SQL> CREATE VIEW SV2 AS SELECT EMPNO, ENAME, JOB, SAL 
FROM EMP; 
TESTING: 
SQL> INSERT INTO SV2 VALUES (1122,'SAI','HR',8000); ---ALLOW 
SQL> INSERT INTO SV2 VALUES (1122,'WARNER','SR.HR',9500); 
----NOT ALLOW (EMPNO COLUMN IS PRIMARY KEY COLUMN IN EMP TABLE) 

1.WITH CHECK OPTION: 
IT IS A CONSTRAINT WHICH IS USED TO RESTRICT ROWS ON 
BASE TABLE THROUGH A VIEW WHILE PERFORMING DML 
OPERATIONS. 
	 CREATE TABLE TEST1
	 (EMPNO INT PRIMARY KEY,ENAME VARCHAR(10),SAL MONEY)
    --DROP TABLE TEST1
	CREATE VIEW SV3 AS SELECT *FROM TEST1 WHERE SAL=18000 WITH CHECK OPTION
	INSERT INTO SV3 VALUES (1025,'SCOTT',12000); 
	INSERT INTO SV3 VALUES (1025,'SCOTT',58000); 
	INSERT INTO SV3 VALUES (1025,'SCOTT',18000); 
	
	SELECT * FROM SV3

EX: 
SQL> CREATE VIEW SV3 AS SELECT * FROM TEST1 WHERE 
     SAL=18000 WITH CHECK OPTION; 
     TESTING: 
SQL> INSERT INTO SV3 VALUES (1025,'SCOTT',12000); ---NOT ALLOW 
SQL> INSERT INTO SV3 VALUES (1025,'SCOTT',58000); ---NOT ALLOW 
SQL> INSERT INTO SV3 VALUES (1025,'SCOTT',18000); --ALLOWED 

	CREATE TABLE EMPLOYEE(EMPID INT PRIMARY KEY,EMPNAME VARCHAR(20),EMPDESIGNATION VARCHAR(20)
	,DOJ DATE,DEPTID INT )
	--INSERT INTO EMPLOYEE VALUES ()
	CREATE VIEW VW_EMPLOYEE_IT AS SELECT EMPID,EMPNAME,EMPDESIGNATION,DOJ,DEPTID
	FROM EMPLOYEE WHERE DEPTID =10 WITH CHECK OPTION
	INSERT INTO  VW_EMPLOYEE_IT  VALUES(301,'ANUSHA','SE',GETDATE(),20);
    INSERT INTO  VW_EMPLOYEE_IT  VALUES(303,'ANUSHA','SE',GETDATE(),10);

		SELECT * FROM VW_EMPLOYEE_IT

EX: 

CREATE VIEW VW_EMPLOYEE_IT AS SELECT EMPID, EMPNAME, 
EMPDESIGNATION, DOJ,DEPTID FROM EMPLOYEE WHERE DEPTID 
= 10 WITH CHECK OPTION; 
TESTING: 
INSERT 
INTO 
VW_EMPLOYEE_IT 
VALUES(301,'ANUSHA','SE',GETDATE(),20);--NOT ALLOWED 
INSERT 
INTO 
VW_EMPLOYEE_IT 
VALUES(301,'ANUSHA','SE',GETDATE(),10);--ALLOWED 





2. WITH ENCRYPTION: THE VIEW DEFINITION IS STORED IN AN ENCRYPTED FORMAT. 
	: WILL NOT BE VISIBLE TO ANY USERS 
	: SPECIFIED AT THE HEADER LEVEL 

     CREATE VIEW VW_EMPLOYEE_IT1  WITH ENCRYPTION AS 
	 SELECT EMPID,EMPNAME,EMPDESIGNATION,DEPTID
	 FROM EMPLOYEE WHERE DEPTID=10 

	 
     CREATE VIEW VW_EMPLOYEE_IT3 WITH ENCRYPTION AS 
	 SELECT EMPID,EMPNAME,EMPDESIGNATION,DEPTID
	 FROM DBO.EMPLOYEE WHERE DEPTID=10 

	 SELECT * FROM VW_EMPLOYEE_IT3

	 SELECT definition FROM sys.sql_modules WHERE object_id = OBJECT_ID('dbo.MyEncryptedView');
	 SELECT definition FROM sys.sql_modules WHERE object_id = OBJECT_ID('DBO.VW_EMPLOYEE_IT3');



	 SELECT * FROM VW_EMPLOYEE_IT1
	 INSERT INTO VW_EMPLOYEE_IT1 VALUES(302,'ANUSHA','SE',10)

	 SELECT * FROM SYSOBJECTS WHERE XTYPE='V'-- VIEWS 
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='S'-- SYSTEM TABLES
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='U'-- USER TABLES
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='PK'-- PRIMARY KEY
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='F' -- FORIGN KEY
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='UQ'-- UNIQUE 
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='C'-- CHECK
	 SELECT * FROM SYSOBJECTS WHERE XTYPE='SO'--SEQUENCE									
	SELECT * FROM SYSOBJECTS WHERE XTYPE='SN'--SYNONYMS
	SELECT * FROM SYSOBJECTS WHERE XTYPE='SP'-- STORE PROCEDURE										
	SELECT * FROM SYSOBJECTS WHERE XTYPE='FN'-- FUNCTIONS										
											

EX: 


CREATE VIEW VW_EMPLOYEE_IT WITH ENCRYPTION   
AS SELECT EMPID, EMPNAME, EMPDESIGNATION, DEPTID FROM 
EMPLOYEE WHERE DEPTID = 10; 

TESTING: 
SELECT TEXT FROM SYSOBJECTS WHERE XTYPE='V'; 
METADATA TABLES / READ ONLY TABLES: 
THESE ARE STORING DATA ABOUT DATA. 
ALL METADATA TABLES ARE PREDEFINE TABLES .
IT SUPPORTS “SELECT” COMMAND ONLY.WE CANNOT MANIPULATE THE DATA. 
SYSOBJECTS: CONTAINS INFORMATION OF EACH AND EVERY 
OBJECT WHICH WAS CREATED UNDER DATABASE.LIKE TABLES, 
VIEWS, SEQUENCE, CONSTRAINTS, PROCEDURES, FUNCTIONS 
………………. ETC. 
WE CAN FIND OUT WHAT TYPE OF OBJECT THEN USE 
“XTYPE” COLUMN OF SYSOBJECTS. 
XTYPE VALUES: 
S: SYSTEM TABLES 
U: USER TABLES 
V: VIEWS 
PK: PRIMARY KEY 
F: FOREIGN KEY 
UQ: UNIQUE 
C: CHECK 
SO: SEQUENCE 
SN: SYNONYM 
SP: STORED PROCEDURE 
FN: FUNCTIONS 
SYNTAX: 
SELECT * FROM SYSOBJECTS WHERE XTYPE=’VALUE’; 
EX: 
SELECT * FROM SYSOBJECTS WHERE XTYPE='S'; 
SELECT * FROM SYSOBJECTS WHERE XTYPE=’U’; 
SELECT * FROM SYSOBJECTS WHERE XTYPE=’V’; 




SYSCOLUMNS: INFORMATION OF EACH & EVERY COLUMN 
ASSOCIATED WITH TABLE (OR) VIEW. 
EX: SELECT * FROM SYSCOLUMNS WHERE ID=OBJECT_ID(‘EMP’); 
				SELECT * FROM SYSCOLUMNS WHERE ID=OBJECT_ID('EMP')



SYSCOMMENTS: THIS WILL CONTAINS INFORMATION ABOUT 
VIEW OBJECTS. 
EX: SELECT * FROM SYSCOMMENTS WHERE 
ID=OBJECT_ID(‘VIEW1’); 
			SELECT* FROM SYSCOMMENTS WHERE ID=OBJECT_ID('VIEW1')
				SELECT * FROM SYSCOMMENTS WHERE ID=OBJECT_ID('VW_EMPLOYEE_IT')
				SELECT * FROM SYSCOMMENTS WHERE ID=OBJECT_ID('VW_EMPLOYEE_IT1')
			    SELECT * FROM SYSCOMMENTS WHERE ID=OBJECT_ID('SV1')
			    SELECT * FROM SYSCOMMENTS WHERE ID=OBJECT_ID('SV2')
			    SELECT * FROM SYSCOMMENTS WHERE ID=OBJECT_ID('SV3')


3. WITH SCHEMABINDING: DOES NOT ALLOW TO DROP A BASE 
TABLE AND ALSO NOT ALLOWED MODIFICATION TO THE 
UNDERLYING DATABASE OBJECTS / COLUMNS WHICH THE VIEW IS 
USING. - SHOULD BE SPECIFIED AT THE HEARDER LEVEL 
TWO RULES: 
A. USE OF * IS NOT ALLOWED IN THE SELECT QUERY. 
B. OBJECTS SHOULD REFER WITH A AND TWO - PART NAME(DBO.<TN>) EX: DBO.EMPLOYEE

			CREATE VIEW VW_EMPLOYEE_IT2 WITH SCHEMABINDING
			AS 
			SELECT EMPID,EMPNAME,EMPDESIGNATION,DOJ,DEPTID FROM DBO.EMPLOYEE
			WHERE DEPTID=10 WITH CHECK OPTION

SELECT * FROM VW_EMPLOYEE_IT2
DROP TABLE EMPLOYEE			
			DROP VIEW VW_EMPLOYEE_IT2

EX: 
CREATE VIEW VW_EMPLOYEE_IT WITH SCHEMABINDING 
AS  
SELECT EMPID, EMPNAME, EMPDESIGNATION, DOJ,DEPTID FROM 
DBO.EMPLOYEE WHERE DEPTID = 10 WITH CHECK OPTION; 
TESTING: 
DROP TABLE EMPLOYEE; ----ERROR 


2.COMPLEX VIEWS: A VIEW IS CALLED AS COMPLEX VIEW, 
I) WHEN WE CREATE ON MULTIPLE BASE TABLES. 
II) WHEN WE CREATE A VIEW WITH AGGREGATIVE 
FUNCTIONS, GROUP BY, HAVING CLAUSES, SET OPERATORS, 
DISTINCT KEY WORD. - COMPLEX VIEW ARE NOT SUPPORTS DML OPERATIONS. 



EX1:

SQL> CREATE VIEW CV1 AS SELECT * FROM STUDENT S INNER 
JOIN COURSE C ON S.CID=C.CID; 
ERROR: 
COLUMN NAMES IN EACH VIEW OR FUNCTION MUST BE UNIQUE. 
COLUMN NAME 'CID' IN VIEW OR FUNCTION 'CV1' IS SPECIFIED 
MORE THAN ONCE. 

EX:  
CREATE VIEW CV1 AS SELECT STID, SNAME, C.CID, CNAME, CFEE 
FROM STUDENT S INNER JOIN COURSE C ON S.CID=C.CID; 

NOW WE CREATED A COMPLEX VIEW ON MULTIPLE 
TABLES.BUT NOT ALLOW DML OPERATIONS.

DML OPERATIONS THROUGH A COMPLEX VIEW: 

INSERT INTO CV1 VALUES (105,’WARD’,50,’DBA’,5000); ---ERROR 
UPDATE CV1 SET CFEE=3000 WHERE STID=101; ---ERROR 
DELETE FROM CV1 WHERE STID=102; ----ERROR 

EX2: 
SQL> CREATE VIEW CV2 AS  
SELECT * FROM EMP_HYD 
UNION 
SELECT * FROM EMP_CHENNAI; 

> THE ABOVE COMPLEX VIEW CV2 IS NOT ALLOW DML 
OPERATIONS. 
SELECT *FROM EMP
EX3: 
SQL> CREATE VIEW CV3 AS SELECT ENAME, SUM(SAL)  FROM 
EMP GROUP BY ENAME; 

SELECT * FROM CV3

ERROR: CREATE VIEW OR FUNCTION FAILED BECAUSE NO 
COLUMN NAME WAS SPECIFIED FOR COLUMN 2. 
NOTE: WHEN WE CREATE A VIEW WITH FUNCTION COLUMN 
OPERATION THEN WE MUST CREATE ALIAS NAME FOR THOSE 
FUNCTION COLUMN OTHERWISE SQLSERVER RETURNS AN ERROR. 

EX: 
SQL> CREATE VIEW CV3 AS SELECT DEPTNO, SUM(SAL) AS 
SUMSAL FROM EMP GROUP BY DEPTNO; 

> THE ABOVE COMPLEX VIEW CV3 NOT ALLOWED DML 
OPERATIONS. 
SELECT * FROM DEPT
SELECT *FROM EMP
CREATE TABLE DEPT1 ( DEPTNO INT,DNAME VARCHAR(20))
INSERT INTO DEPT1 VALUES(1,'AA')

CREATE VIEW CV4 AS SELECT EMPNO,ENAME,SAL,D.DEPT,D.LOC
FROM
EMP E JOIN DEPT D ON E.EMPNO=D.ID

DELETE FROM CV4 WHERE EMPNO=5
UPDATE CV4
SET EMPNO=5
WHERE SAL =21000
UPDATE CV4
SET EMPNO=4
WHERE SAL =24000
UPDATE CV4
SET EMPNO=3
WHERE SAL =42000
UPDATE CV4
SET EMPNO=2
WHERE SAL =4000
UPDATE CV4
SET EMPNO=1
WHERE SAL =2000


INSERT INTO CV4 VALUES(1,'AA',20000,12,'HYD')
DELETE FROM CV4 WHERE EMPNO=1122
INSERT INTO DEPT VALUES (1,'HR','IND')
INSERT INTO DEPT VALUES (2,'HR','PAK')
INSERT INTO DEPT VALUES (3,'HR','CND')
INSERT INTO DEPT VALUES (4,'HR','UK')
INSERT INTO DEPT VALUES (5,'HR','AUS')

SELECT * FROM CV4
INSERT INTO EMP VALUES(1,'RAM','HR',2000)
INSERT INTO EMP VALUES(2,'RAM','HR',4000)
INSERT INTO EMP VALUES(3,'RAM','HR',42000)
INSERT INTO EMP VALUES(4,'RAM','HR',24000)
INSERT INTO EMP VALUES(5,'RAM','HR',21000)

EX4: 
SQL> CREATE VIEW CV4 AS SELECT EMPNO, ENAME, SAL, D. 
DEPTNO, DNAME, LOC FROM EMP E INNER JOIN DEPT D ON E. 
DEPTNO=D.DEPTNO; 

				CREATE VIEW CV4 AS SELECT EMPNO,ENAME,SAL,D.DEPT,D.LOC
				FROM
                EMP E JOIN DEPT D ON E.EMPNO=D.ID
				SELECT * FROM CV4
UPDATE CV4 SET SAL=500 , LOC ='AFG' WHERE EMPNO=1  ---WHICH MEANS DOEST EFFECT TWO BASE TABLES ITS NOT ALLOWED

 DELETE FROM CV4 WHERE EMPNO=1 AND LOC='IND' ---NOT ALLOWED


TESTING: 

SQL> UPDATE CV4 SET SAL=500 WHERE EMPNO=7788; -- ALLOWED 
SQL> DELETE FROM CV4 WHERE EMPNO=7782; ----ALOOWED 

SQL> INSERT INTO CV4 VALUES (1122,'SAI',6000,10,'SAP','HYD'); ---NOT ALLOW 


ADVANTAGES OF VIEWS: 
1. IT IS PROVIDING SECURITY.IT MEANS THAT TO EACH USER 
CAN BE GIVEN PERMISSION TO ACCESS SPECIFIC COLUMNS & 
SPECIFIC ROWS FROM A TABLE. 
2. IF DATA IS ACCESSED AND ENTERED THROUGH A VIEW, THE DB 
SERVER WILL CHECK DATA TO ENSURE THAT IT MEETS SPECIFIED 
INTERGRITY CONSTRAINTS RULES OR NOT. 
3. QUERY SIMPLIFY IT MEANS THAT TO REDUCE COMPLEX QUERY. 
4. VIEW IS STORED SQL QUERY. 
SYNTAX TO DROP A VIEW: 
SQL> DROP VIEW <VIEW NAME>; 
EX: 
SQL> DROP VIEW SV1; 
SQL> DROP VIEW CV1; 
SQL> DROP VIEW FV1; 





SELECT name, enabled
FROM msdb.dbo.sysjobs
ORDER BY enabled DESC;


CREATE TABLE EMPLOYEESALARIES
(
EmployeeID INT

BaseSalary DECIMAL(10,2)

Bonus DECIMAL(10,2)

DepartmentID INT
)



CREATE TABLE EMPLOYEESALARIES
(
EmployeeID INT,

BaseSalary DECIMAL(10,2),

Bonus DECIMAL(10,2),

DepartmentID INT
)

CREATE VIEW dbo.EmployeeTotalSalaryVW
WITH ENCRYPTION
AS
SELECT 
    EmployeeID,
    DepartmentID,
    (BaseSalary + Bonus) AS TotalSalary
FROM EmployeeSalaries;

SELECT* FROM EmployeeTotalSalaryVW


Calculates the TotalSalary for each employee (BaseSalary + Bonus).

Hides the raw salary details (BaseSalary, Bonus) from casual users.

Prevents users from viewing the SQL logic behind the view.



How would you create such a view?

How can you ensure users cannot see the source code of the view?

Can users update data through this view? Why or why not?


