
---------------By USING LEAD AND LAG 

SELECT  NAME,SALARY, SUM(SALARY) OVER ( ORDER BY SALARY) AS RUNNING_TOTAL,
ISNULL(LAG(SALARY) OVER(ORDER BY SALARY),0) AS PREVIOUS,
ISNULL(LEAD(SALARY) OVER (ORDER BY SALARY),0) AS NEXT
FROM ABCD
GROUP BY SALARY,NAME;

----------------------------------------------------------------------------------


CREATE TABLE #ABCD
(ID INT,NAME VARCHAR(20),SALARY INT,CUMULATIVE_SALARY INT,PREV_SALARY INT,
NEXT_SALARY INT);

DECLARE @ID INT,@NAME VARCHAR(20),@SALARY INT,@CUMULATIVE_SALARY INT =0,@PREV_SALARY INT,
@NEXT_SALARY INT;


DECLARE salary_cursor cursor for 
SELECT ID,NAME,SALARY FROM ABCD ORDER BY ID;

OPEN SALARY_CURSOR;
FETCH NEXT FROM SALARY_CURSOR INTO @ID,@NAME,@SALARY;

WHILE @@FETCH_STATUS=0
BEGIN
SET @CUMULATIVE_SALARY =@CUMULATIVE_SALARY+@SALARY;


SELECT TOP 1  @NEXT_SALARY=SALARY FROM ABCD
WHERE ID>@ID
ORDER BY ID ASC;

INSERT INTO #ABCD (ID,NAME,SALARY,CUMULATIVE_SALARY,PREV_SALARY,NEXT_SALARY)
VALUES(@ID,@NAME,@SALARY,@CUMULATIVE_SALARY,@PREV_SALARY,@NEXT_SALARY);
   
   
   SET @PREV_SALARY = @SALARY;


    SET @NEXT_SALARY = NULL;

    FETCH NEXT FROM salary_cursor INTO @ID, @NAME, @SALARY;
END


CLOSE salary_cursor;
DEALLOCATE salary_cursor;

DROP TABLE #ABCD

SELECT * FROM ABCD
SELECT * FROM #ABCD;
-------------------------------------------------------------------

CREATE TABLE #ABCD1(ID INT,NAME VARCHAR(100),SALARY INT,CUMULATIVE_SALARY INT,PREV_SALARY INT,
NEXT_SALARY INT);

DECLARE @ID1 INT,@NAME1 VARCHAR(100),@SALARY1 INT,@CUMULATIVE_SALARY1 INT=0,
@PREV_SALARY1 INT,@NEXT_SALARY1 INT;


DECLARE SALARY_CURSOR1 CURSOR FOR SELECT ID,NAME,SALARY FROM ABCD ORDER BY ID ASC;

OPEN SALARY_CURSOR1 ;

FETCH NEXT FROM SALARY_CURSOR1 INTO @ID1,@NAME1,@SALARY1;

WHILE @@FETCH_STATUS=0 
BEGIN 

SET @CUMULATIVE_SALARY1 = @CUMULATIVE_SALARY1+ @SALARY1;
SELECT TOP 1 @NEXT_SALARY1 = SALARY FROM ABCD
WHERE ID>@ID1 
--ORDER BY ID ASC;

INSERT INTO #ABCD1 
VALUES (@ID1,@NAME1,@SALARY1,@CUMULATIVE_SALARY1,@PREV_SALARY1,@NEXT_SALARY1)

SET @PREV_SALARY1 =@SALARY1;

SET @NEXT_SALARY1 = NULL;

FETCH NEXT FROM SALARY_CURSOR1 INTO @ID1,@NAME1,@SALARY1;

END

CLOSE SALARY_CURSOR1
DEALLOCATE SALARY_CURSOR1
DROP TABLE #ABCD1

SELECT * FROM #ABCD1


SELECT TOP 1 SALARY FROM ABCD
WHERE ID>ID

SELECT * FROM ABCD

SELECT A.ID,A.SALARY
,(SELECT SUM(B.SALARY ) FROM ABCD B WHERE B.ID <=A.ID)
FROM ABCD A

SELECT 
  A.ID,
  A.SALARY,
  (SELECT SUM(B.SALARY) FROM ABCD B WHERE B.ID<=A.ID) AS RUNNING,
 
 (SELECT B.SALARY  FROM ABCD B
   WHERE B.ID = (SELECT MAX(ID) FROM ABCD  WHERE ID < A.ID)
  ) AS LAG_SALARY,
  (SELECT B.SALARY  FROM ABCD B
   WHERE B.ID = (SELECT MIN(ID) FROM ABCD WHERE ID > A.ID)
  ) AS LEAD_SALARY

FROM ABCD A
ORDER BY A.ID;
-------------------------------------------------------

SELECT 
    A.ID,
    A.SALARY,
	(SELECT SUM(B.SALARY) FROM ABCD B WHERE B.ID<=A.ID) AS RUNNING,
    prev.SALARY AS PRESALARY,   
    nxt.SALARY AS NXTSALARY   

FROM ABCD  A

OUTER APPLY (
    SELECT TOP 1 SALARY
    FROM ABCD AS p
    WHERE p.ID < A.ID
    ORDER BY p.ID DESC
) AS prev

OUTER APPLY (
    SELECT TOP 1 SALARY
    FROM ABCD AS n
    WHERE n.ID >A.ID
    ORDER BY n.ID ASC
) AS nxt
ORDER BY A.ID;

SELECT * FROM ABCD A FULL OUTER JOIN ABCD B ON A.ID=B.ID

SELECT * FROM ABCD A CROSS APPLY (SELECT NAME FROM ABCD B) B

----------FEBINOCCI_SERIES

;with CTE (N,A,B) as 
(
select 1 as INT,CAST(0 as BIGINT),CAST (1 AS BIGINT)
UNION ALL 
SELECT N+1,B,A+B
FROM CTE 
WHERE N<92
)
SELECT N,A FROM CTE 

OPTION (MAXRECURSION 0);

---------------------------------------
select * from fibonacci_series1
--DROP TABLE fibonacci_series1


CREATE TABLE fibonacci_series1 (
    number INT PRIMARY KEY,
    fibonacci_number BIGINT
);



DECLARE @n INT = 1;  -- Term number
DECLARE @a BIGINT = 0;  -- First number
DECLARE @b BIGINT = 1;  -- Second number
DECLARE @temp BIGINT;
DECLARE @max_terms INT = 92;  -- Up to 92 to avoid arthemetic overflow

WHILE @n <= @max_terms
BEGIN
    INSERT INTO fibonacci_series1 (number, fibonacci_number)
    VALUES (@n, @a);
    SET @temp = @a + @b;
    SET @a = @b;
    SET @b = @temp;
    SET @n = @n + 1;
END;


--------------------------------------------------------------------------
go
--palindrome
CREATE OR ALTER PROC U_palindrome(
@n nvarchar(20)
)
AS
BEGIN
	DECLARE @p nvarchar(20)='',@k int
	SET @k=len(@n)
	WHILE @k>0
	BEGIN
		SET @p=@p+substring(@n,@k,1)
		SET @k=@k-1
	END
	PRINT @p 
	IF @p=@n
	 BEGIN
		PRINT 'IT IS PALINDROME'
	END
	ELSE
	BEGIN
	 PRINT 'it is not palindrome'
	END
END
GO
EXEC  U_palindrome 12121
